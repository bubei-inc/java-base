package com.son.classloader;

public class ClassRefDad {


    // 类何时才会被初始化
    /************************************************直接引用*****************************************************/
    // 1. 创建类对象  ClassSon son = new ClassSon();
    // 2. 访问类的静态变量， final修饰的为常量， 常量生成的字节码编译器不会放入到对象载入域中，二是会直接放在字节码中。
    // 3. 访问类的静态方法
    // 4. Class.forName("com.son.classloader.ClassName"), 不仅仅会将对象放入到jvm内存中， 同时会初始化对象。 ClassLoader.getClassLoader()只会实现第一步。
    // 5. 初始化类时，父类未被初始化会优先初始化父类。
    // 6. 虚拟机启动时main类会优先被初始化。

    /*****************************************************************************************************/

    /*********************************************间接引用*******************************************************/
    //1. 子类调用父类静态变量，只有父类被初始化， 子类不会被初始化。
    // 2. 通过数组来定义来引用类，不会触发类的初始化。
    // 3. 访问类的常量不会初始化类。
    /*********************************************间接引用*******************************************************/
    /*********************************************类初始化顺序*******************************************************/
    // 1.类从顶至底的顺序初始化，所以声明在顶部的字段的早于底部的字段初始化
    //2.超类早于子类和衍生类的初始化
    //3.如果类的初始化是由于访问静态域而触发，那么只有声明静态域的类才被初始化，而不会触发超类的初始化或者子类的。
    //4.初始化即使静态域被子类或子接口或者它的实现类所引用。
    //5.接口初始化不会导致父接口的初始化。
    //6.静态域的初始化是在类的静态初始化期间，非静态域的初始化时在类的实例创建期间。这意味这静态域初始化在非静态域之前。
    //7.非静态域通过构造器初始化，子类在做任何初始化之前构造器会隐含地调用父类的构造器，他保证了非静态或实例变量（父类）初始化早于子类
    /*********************************************类初始化顺序*******************************************************/
    public static String CLASS_REF = "hello";

    static {
        System.out.println("Dad init ==== ");
    }

    private String name;

    public ClassRefDad() {
        System.out.println("default constructor init ------");
    }

    public ClassRefDad(String name) {
        this.name = name;
    }


}
